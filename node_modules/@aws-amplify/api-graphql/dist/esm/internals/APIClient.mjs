import { resolveOwnerFields } from '../utils/resolveOwnerFields.mjs';
import { __authMode, __authToken, __headers } from '../types/index.mjs';

// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
const connectionType = {
    HAS_ONE: 'HAS_ONE',
    HAS_MANY: 'HAS_MANY',
    BELONGS_TO: 'BELONGS_TO',
};
/**
 *
 * @param GraphQL response object
 * @returns response object with `items` properties flattened
 */
const flattenItems = (obj) => {
    const res = {};
    Object.entries(obj).forEach(([prop, value]) => {
        if (typeof value === 'object' && value !== null) {
            if (value.items !== undefined) {
                res[prop] = value.items.map((item) => flattenItems(item));
                return;
            }
            res[prop] = flattenItems(value);
            return;
        }
        res[prop] = value;
    });
    return res;
};
// TODO: this should accept single result to support CRUD methods; create helper for array/list
function initializeModel(client, modelName, result, modelIntrospection, authMode, authToken, context = false) {
    const introModel = modelIntrospection.models[modelName];
    const introModelFields = introModel.fields;
    const modelFields = Object.entries(introModelFields)
        .filter(([_, field]) => field?.type?.model !== undefined)
        .map(([fieldName]) => fieldName);
    return result.map(record => {
        const initializedRelationalFields = {};
        for (const fieldName of modelFields) {
            const modelField = introModelFields[fieldName];
            const modelFieldType = modelField?.type;
            const relatedModelName = modelFieldType.model;
            const relatedModel = modelIntrospection.models[relatedModelName];
            const relatedModelPKFieldName = relatedModel.primaryKeyInfo.primaryKeyFieldName;
            const relatedModelSKFieldNames = relatedModel.primaryKeyInfo.sortKeyFieldNames;
            const relationType = modelField.association?.connectionType;
            let connectionFields = [];
            if (modelField.association &&
                'associatedWith' in modelField.association) {
                connectionFields = modelField.association.associatedWith;
            }
            let targetNames = [];
            if (modelField.association && 'targetNames' in modelField.association) {
                targetNames = modelField.association.targetNames;
            }
            switch (relationType) {
                case connectionType.HAS_ONE:
                case connectionType.BELONGS_TO:
                    const sortKeyValues = relatedModelSKFieldNames.reduce((acc, curVal) => {
                        if (record[curVal]) {
                            return (acc[curVal] = record[curVal]);
                        }
                    }, {});
                    if (context) {
                        initializedRelationalFields[fieldName] = (contextSpec, options) => {
                            if (record[targetNames[0]]) {
                                return client.models[relatedModelName].get(contextSpec, {
                                    [relatedModelPKFieldName]: record[targetNames[0]],
                                    ...sortKeyValues,
                                }, {
                                    authMode: options?.authMode || authMode,
                                    authToken: options?.authToken || authToken,
                                });
                            }
                            return undefined;
                        };
                    }
                    else {
                        initializedRelationalFields[fieldName] = (options) => {
                            if (record[targetNames[0]]) {
                                return client.models[relatedModelName].get({
                                    [relatedModelPKFieldName]: record[targetNames[0]],
                                    ...sortKeyValues,
                                }, {
                                    authMode: options?.authMode || authMode,
                                    authToken: options?.authToken || authToken,
                                });
                            }
                            return undefined;
                        };
                    }
                    break;
                case connectionType.HAS_MANY:
                    const parentPk = introModel.primaryKeyInfo.primaryKeyFieldName;
                    const parentSK = introModel.primaryKeyInfo.sortKeyFieldNames;
                    // M:N check - TODO: refactor
                    const relatedModelField = relatedModel.fields[connectionFields[0]];
                    const relatedModelFieldType = relatedModelField.type;
                    if (relatedModelFieldType.model) {
                        let relatedTargetNames = [];
                        if (relatedModelField.association &&
                            'targetNames' in relatedModelField.association) {
                            relatedTargetNames = relatedModelField.association?.targetNames;
                        }
                        const hasManyFilter = relatedTargetNames.map((field, idx) => {
                            if (idx === 0) {
                                return { [field]: { eq: record[parentPk] } };
                            }
                            return { [field]: { eq: record[parentSK[idx - 1]] } };
                        });
                        if (context) {
                            initializedRelationalFields[fieldName] = (contextSpec, options) => {
                                if (record[parentPk]) {
                                    return client.models[relatedModelName].list(contextSpec, {
                                        filter: { and: hasManyFilter },
                                        limit: options?.limit,
                                        nextToken: options?.nextToken,
                                        authMode: options?.authMode || authMode,
                                        authToken: options?.authToken || authToken,
                                    });
                                }
                                return [];
                            };
                        }
                        else {
                            initializedRelationalFields[fieldName] = (options) => {
                                if (record[parentPk]) {
                                    return client.models[relatedModelName].list({
                                        filter: { and: hasManyFilter },
                                        limit: options?.limit,
                                        nextToken: options?.nextToken,
                                        authMode: options?.authMode || authMode,
                                        authToken: options?.authToken || authToken,
                                    });
                                }
                                return [];
                            };
                        }
                        break;
                    }
                    const hasManyFilter = connectionFields.map((field, idx) => {
                        if (idx === 0) {
                            return { [field]: { eq: record[parentPk] } };
                        }
                        return { [field]: { eq: record[parentSK[idx - 1]] } };
                    });
                    if (context) {
                        initializedRelationalFields[fieldName] = (contextSpec, options) => {
                            if (record[parentPk]) {
                                return client.models[relatedModelName].list(contextSpec, {
                                    filter: { and: hasManyFilter },
                                    limit: options?.limit,
                                    nextToken: options?.nextToken,
                                    authMode: options?.authMode || authMode,
                                    authToken: options?.authToken || authToken,
                                });
                            }
                            return [];
                        };
                    }
                    else {
                        initializedRelationalFields[fieldName] = (options) => {
                            if (record[parentPk]) {
                                return client.models[relatedModelName].list({
                                    filter: { and: hasManyFilter },
                                    limit: options?.limit,
                                    nextToken: options?.nextToken,
                                    authMode: options?.authMode || authMode,
                                    authToken: options?.authToken || authToken,
                                });
                            }
                            return [];
                        };
                    }
                    break;
            }
        }
        return { ...record, ...initializedRelationalFields };
    });
}
const graphQLOperationsInfo = {
    CREATE: { operationPrefix: 'create', usePlural: false },
    READ: { operationPrefix: 'get', usePlural: false },
    UPDATE: { operationPrefix: 'update', usePlural: false },
    DELETE: { operationPrefix: 'delete', usePlural: false },
    LIST: { operationPrefix: 'list', usePlural: true },
    ONCREATE: { operationPrefix: 'onCreate', usePlural: false },
    ONUPDATE: { operationPrefix: 'onUpdate', usePlural: false },
    ONDELETE: { operationPrefix: 'onDelete', usePlural: false },
    OBSERVE_QUERY: { operationPrefix: 'observeQuery', usePlural: false },
};
const graphQLDocumentsCache = new Map();
const SELECTION_SET_WILDCARD = '*';
function defaultSelectionSetForModel(modelDefinition) {
    // fields that are explicitly part of the graphql schema; not
    // inferred from owner auth rules.
    const { fields } = modelDefinition;
    const explicitFields = Object.values(fields)
        .map(({ type, name }) => typeof type === 'string' && name) // Default selection set omits model fields
        .filter(Boolean);
    // fields used for owner auth rules that may or may not also
    // be explicit on the model.
    const ownerFields = resolveOwnerFields(modelDefinition);
    return Array.from(new Set(explicitFields.concat(ownerFields)));
}
const FIELD_IR = '';
/**
 * Generates nested Custom Selection Set IR from path
 *
 * @param modelDefinitions
 * @param modelName
 * @param selectionSet - array of object paths
 * @example
 * ### Given
 * `selectionSet = ['id', 'comments.post.id']`
 * ### Returns
 * ```ts
 * {
 *   id: '',
 *   comments: {
 *     items: { post: { id: '' } }
 *   }
 * }
 * ```
 */
function customSelectionSetToIR(modelDefinitions, modelName, selectionSet) {
    const modelDefinition = modelDefinitions[modelName];
    const { fields: modelFields } = modelDefinition;
    return selectionSet.reduce((resultObj, path) => {
        const [fieldName, nested, ...rest] = path.split('.');
        if (nested) {
            const fieldType = modelFields[fieldName]?.type;
            const relatedModel = fieldType.model;
            if (!relatedModel) {
                // TODO: may need to change this to support custom types
                throw Error(`${fieldName} is not a model field`);
            }
            const relatedModelDefinition = modelDefinitions[relatedModel];
            const selectionSet = nested === SELECTION_SET_WILDCARD
                ? defaultSelectionSetIR(relatedModelDefinition)
                : // if we have a path like 'field.anotherField' recursively build up selection set IR
                    customSelectionSetToIR(modelDefinitions, relatedModel, [
                        [nested, ...rest].join('.'),
                    ]);
            if (modelFields[fieldName]?.isArray) {
                const existing = resultObj[fieldName] || {
                    items: {},
                };
                const merged = { ...existing.items, ...selectionSet };
                resultObj[fieldName] = { items: merged };
                return resultObj;
            }
            const existingItems = resultObj[fieldName] || {};
            const merged = { ...existingItems, ...selectionSet };
            resultObj[fieldName] = merged;
            return resultObj;
        }
        const exists = Boolean(modelFields[fieldName]);
        if (!exists) {
            throw Error(`${fieldName} is not a field of model ${modelName}`);
        }
        resultObj[fieldName] = FIELD_IR;
        return resultObj;
    }, {});
}
const defaultSelectionSetIR = (relatedModelDefinition) => {
    const defaultSelectionSet = defaultSelectionSetForModel(relatedModelDefinition);
    const reduced = defaultSelectionSet.reduce((acc, curVal) => {
        acc[curVal] = FIELD_IR;
        return acc;
    }, {});
    return reduced;
};
/**
 * Stringifies selection set IR
 * * @example
 * ### Given
 * ```ts
 * {
 *   id: '',
 *   comments: {
 *     items: { post: { id: '' } }
 *   }
 * }
 * ```
 * ### Returns
 * `'id comments { items { post { id } } }'`
 */
function selectionSetIRToString(obj) {
    const res = [];
    Object.entries(obj).forEach(([fieldName, value]) => {
        if (value === FIELD_IR) {
            res.push(fieldName);
        }
        else if (typeof value === 'object' && value !== null) {
            if (value?.items) {
                res.push(fieldName, '{', 'items', '{', selectionSetIRToString(value.items), '}', '}');
            }
            else {
                res.push(fieldName, '{', selectionSetIRToString(value), '}');
            }
        }
    });
    return res.join(' ');
}
function generateSelectionSet(modelDefinitions, modelName, selectionSet) {
    const modelDefinition = modelDefinitions[modelName];
    if (!selectionSet) {
        return defaultSelectionSetForModel(modelDefinition).join(' ');
    }
    const selSetIr = customSelectionSetToIR(modelDefinitions, modelName, selectionSet);
    const selSetString = selectionSetIRToString(selSetIr);
    return selSetString;
}
function generateGraphQLDocument(modelDefinitions, modelName, modelOperation, listArgs) {
    const modelDefinition = modelDefinitions[modelName];
    const { name, pluralName, fields, primaryKeyInfo: { isCustomPrimaryKey, primaryKeyFieldName, sortKeyFieldNames, }, } = modelDefinition;
    const { operationPrefix, usePlural } = graphQLOperationsInfo[modelOperation];
    const { selectionSet } = listArgs || {};
    const fromCache = graphQLDocumentsCache.get(name)?.get(modelOperation);
    if (fromCache !== undefined) {
        return fromCache;
    }
    if (!graphQLDocumentsCache.has(name)) {
        graphQLDocumentsCache.set(name, new Map());
    }
    const graphQLFieldName = `${operationPrefix}${usePlural ? pluralName : name}`;
    let graphQLOperationType;
    let graphQLSelectionSet;
    let graphQLArguments;
    const selectionSetFields = generateSelectionSet(modelDefinitions, modelName, selectionSet);
    switch (modelOperation) {
        case 'CREATE':
        case 'UPDATE':
        case 'DELETE':
            graphQLArguments ??
                (graphQLArguments = {
                    input: `${operationPrefix.charAt(0).toLocaleUpperCase() +
                        operationPrefix.slice(1)}${name}Input!`,
                });
            graphQLOperationType ?? (graphQLOperationType = 'mutation');
        case 'READ':
            graphQLArguments ??
                (graphQLArguments = isCustomPrimaryKey
                    ? [primaryKeyFieldName, ...sortKeyFieldNames].reduce((acc, fieldName) => {
                        acc[fieldName] = fields[fieldName].type;
                        return acc;
                    }, {})
                    : {
                        [primaryKeyFieldName]: `${fields[primaryKeyFieldName].type}!`,
                    });
            graphQLSelectionSet ?? (graphQLSelectionSet = selectionSetFields);
        case 'LIST':
            graphQLArguments ??
                (graphQLArguments = {
                    filter: `Model${name}FilterInput`,
                    limit: 'Int',
                    nextToken: 'String',
                });
            graphQLOperationType ?? (graphQLOperationType = 'query');
            graphQLSelectionSet ??
                (graphQLSelectionSet = `items { ${selectionSetFields} } nextToken __typename`);
        case 'ONCREATE':
        case 'ONUPDATE':
        case 'ONDELETE':
            graphQLArguments ??
                (graphQLArguments = {
                    filter: `ModelSubscription${name}FilterInput`,
                });
            graphQLOperationType ?? (graphQLOperationType = 'subscription');
            graphQLSelectionSet ?? (graphQLSelectionSet = selectionSetFields);
            break;
        case 'OBSERVE_QUERY':
        default:
            throw new Error('Internal error: Attempted to generate graphql document for observeQuery. Please report this error.');
    }
    const graphQLDocument = `${graphQLOperationType}${graphQLArguments
        ? `(${Object.entries(graphQLArguments).map(([fieldName, type]) => `\$${fieldName}: ${type}`)})`
        : ''} { ${graphQLFieldName}${graphQLArguments
        ? `(${Object.keys(graphQLArguments).map(fieldName => `${fieldName}: \$${fieldName}`)})`
        : ''} { ${graphQLSelectionSet} } }`;
    graphQLDocumentsCache.get(name)?.set(modelOperation, graphQLDocument);
    return graphQLDocument;
}
function buildGraphQLVariables(modelDefinition, operation, arg, modelIntrospection) {
    const { fields, primaryKeyInfo: { isCustomPrimaryKey, primaryKeyFieldName, sortKeyFieldNames, }, } = modelDefinition;
    let variables = {};
    // TODO: process input
    switch (operation) {
        case 'CREATE':
            variables = {
                input: arg
                    ? normalizeMutationInput(arg, modelDefinition, modelIntrospection)
                    : {},
            };
            break;
        case 'UPDATE':
            // readonly fields are not  updated
            variables = {
                input: arg
                    ? Object.fromEntries(Object.entries(normalizeMutationInput(arg, modelDefinition, modelIntrospection)).filter(([fieldName]) => {
                        const { isReadOnly } = fields[fieldName];
                        return !isReadOnly;
                    }))
                    : {},
            };
            break;
        case 'READ':
        case 'DELETE':
            // only identifiers are sent
            if (arg) {
                variables = isCustomPrimaryKey
                    ? [primaryKeyFieldName, ...sortKeyFieldNames].reduce((acc, fieldName) => {
                        acc[fieldName] = arg[fieldName];
                        return acc;
                    }, {})
                    : { [primaryKeyFieldName]: arg[primaryKeyFieldName] };
            }
            if (operation === 'DELETE') {
                variables = { input: variables };
            }
            break;
        case 'LIST':
            if (arg?.filter) {
                variables.filter = arg.filter;
            }
            if (arg?.nextToken) {
                variables.nextToken = arg.nextToken;
            }
            if (arg?.limit) {
                variables.limit = arg.limit;
            }
            break;
        case 'ONCREATE':
        case 'ONUPDATE':
        case 'ONDELETE':
            if (arg?.filter) {
                variables = { filter: arg.filter };
            }
            break;
        case 'OBSERVE_QUERY':
            throw new Error('Internal error: Attempted to build variables for observeQuery. Please report this error.');
        default:
            const exhaustiveCheck = operation;
            throw new Error(`Unhandled operation case: ${exhaustiveCheck}`);
    }
    return variables;
}
/**
 * Iterates over mutation input values and resolves any model inputs to their corresponding join fields/values
 *
 * @example
 * ### Usage
 * ```ts
 * const result = normalizeMutationInput({ post: post }, model, modelDefinition);
 * ```
 * ### Result
 * ```ts
 * { postId: "abc123" }
 * ```
 *
 */
function normalizeMutationInput(mutationInput, model, modelIntrospection) {
    const { fields } = model;
    const normalized = {};
    Object.entries(mutationInput).forEach(([inputFieldName, inputValue]) => {
        const fieldType = fields[inputFieldName]?.type;
        const relatedModelName = fieldType?.model;
        if (relatedModelName) {
            const association = fields[inputFieldName]?.association;
            const relatedModelDef = modelIntrospection.models[relatedModelName];
            const relatedModelPkInfo = relatedModelDef.primaryKeyInfo;
            if (association?.connectionType === connectionType.HAS_ONE) {
                const associationHasOne = association;
                associationHasOne.targetNames.forEach((targetName, idx) => {
                    const associatedFieldName = associationHasOne.associatedWith[idx];
                    normalized[targetName] = inputValue[associatedFieldName];
                });
            }
            if (association?.connectionType === connectionType.BELONGS_TO) {
                const associationBelongsTo = association;
                associationBelongsTo.targetNames.forEach((targetName, idx) => {
                    if (idx === 0) {
                        const associatedFieldName = relatedModelPkInfo.primaryKeyFieldName;
                        normalized[targetName] = inputValue[associatedFieldName];
                    }
                    else {
                        const associatedFieldName = relatedModelPkInfo.sortKeyFieldNames[idx - 1];
                        normalized[targetName] = inputValue[associatedFieldName];
                    }
                });
            }
        }
        else {
            normalized[inputFieldName] = inputValue;
        }
    });
    return normalized;
}
/**
 * Produces a parameter object that can contains auth mode/token overrides
 * only if present in either `options` (first) or configured on the `client`
 * as a fallback.
 *
 * @param client Configured client from `generateClient`
 * @param options Args/Options obect from call site.
 * @returns
 */
function authModeParams(client, options = {}) {
    return {
        authMode: options.authMode || client[__authMode],
        authToken: options.authToken || client[__authToken],
    };
}
/**
 * Retrieves custom headers from either the client or request options.
 * @param {client} V6Client | V6ClientSSRRequest | V6ClientSSRCookies - for extracting client headers
 * @param {requestHeaders} [CustomHeaders] - request headers
 * @returns {CustomHeaders} - custom headers
 */
function getCustomHeaders(client, requestHeaders) {
    let headers = client[__headers] || {};
    // Individual request headers will take precedence over client headers.
    // We intentionally do *not* merge client and request headers.
    if (requestHeaders) {
        headers = requestHeaders;
    }
    return headers;
}

export { authModeParams, buildGraphQLVariables, customSelectionSetToIR, flattenItems, generateGraphQLDocument, generateSelectionSet, getCustomHeaders, graphQLOperationsInfo, initializeModel, normalizeMutationInput, selectionSetIRToString };
//# sourceMappingURL=APIClient.mjs.map
